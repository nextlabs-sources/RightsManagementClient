// nxcleanwipe.cpp : Defines the entry point for the console application.
//

#include <Windows.h>
#include "stdafx.h"
#include <string>
#include <Sddl.h>
#include "nxversion.h"
#include "nxcleanwipe.h"

using namespace nxcleanwipe;



// These are defined in .ism files.
#ifdef _WIN64
const wstr ProductCode_7_5(L"{6883F936-4253-4E05-BAFE-623BC08EAB45}");
const wstr ProductCode_7_6(L"{BD9B4764-8D2C-483F-BAC3-C76D6A6B8B45}");
#else
const wstr ProductCode_7_5(L"{7B43936E-CDA6-4A18-B36A-95E17427F116}");
const wstr ProductCode_7_6(L"{ED55711C-BDC3-4365-B466-687A28291413}");
#endif

// These are generated by InstallShield.
#ifdef _WIN64
const wstr PackageCode_7_5(L"{78221A85-8DC5-4FD4-86D4-5573C51C30E5}");
const wstr PackageCode_7_6(L"{6315FCE5-17BE-4F3B-A65F-2A2E1F8189F2}");
#else
const wstr PackageCode_7_5(L"{FD5C54DF-1A49-48DB-BD5D-84A6308E7E58}");
const wstr PackageCode_7_6(L"{878DFCA7-5EDD-41D9-B662-AFEB9423CAB3}");
#endif

// This is defined in .ism files.
const wstr UpgradeCode(L"{1C30F625-2053-4FB0-857E-81C72AFCA6D8}");



typedef enum {
    SILENT,
    NORMAL,
    VERBOSE,
    DEBUG
} mode_t;

mode_t mode = NORMAL;

wstr installDirOverride;
bool wipe7_5 = false, wipe7_6 = false;

VarStore        *pVarStore;
SvcWiper        *pSvcWiper;
AsmWiper        *pAsmWiper;
RegWiper        *pRegWiper;
FileAssocWiper  *pFileAssocWiper;
FontWiper       *pFontWiper;
FileWiper       *pFileWiper;
DirWiper        *pDirWiper;



void printLastError(wstr prefix) {
    if (mode == SILENT) {
        return;
    }

    DWORD lastErr = GetLastError();
    LPWSTR lpBuffer;

    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |
                  FORMAT_MESSAGE_MAX_WIDTH_MASK,
                  NULL, lastErr, 0, (LPWSTR)&lpBuffer, 0, NULL);
    wprintf(L"ERROR %s: %s\n", prefix.c_str(), lpBuffer);
    LocalFree(lpBuffer);
}

wstr squishGUID(wstr guid) {
    // Convert this:    "{12345678-9ABC-DEFG-HIJK-LMNOPQRSTUVW}"
    // to this:         "87654321CBA9GFEDIHKJMLONQPSRUTWV"
    static const struct {short start, len;} squishDict[] = {
        { 1, 8}, {10, 4}, {15, 4}, {20, 2}, {22, 2}, {25, 2}, {27, 2}, {29, 2},
        {31, 2}, {33, 2}, {35, 2}
    };

    wstr squished;

    for (int i = 0; i < _countof(squishDict); i++) {
        for (int j = squishDict[i].start + squishDict[i].len - 1;
             j >= squishDict[i].start;
             j--) {
            squished += guid[j];
        }
    }

    return squished;
}

wstr regKeyStr(HKEY key) {
    static const struct {HKEY key; const wchar_t *str;} keyStrDict[] = {
        {HKEY_CLASSES_ROOT,                 L"HKCR"},
        {HKEY_CURRENT_USER,                 L"HKCU"},
        {HKEY_LOCAL_MACHINE,                L"HKLM"},
        {HKEY_USERS,                        L"HKU"},
        {HKEY_PERFORMANCE_DATA,             L"HKPD"},
        {HKEY_PERFORMANCE_TEXT,             L"HKPT"},
        {HKEY_PERFORMANCE_NLSTEXT,          L"HKPN"},
        {HKEY_CURRENT_CONFIG,               L"HKCC"},
        {HKEY_DYN_DATA,                     L"HKDD"},
        {HKEY_CURRENT_USER_LOCAL_SETTINGS,  L"HKCULS"}
    };

    for (int i = 0; i < _countof(keyStrDict); i++) {
        if (key == keyStrDict[i].key) {
            return keyStrDict[i].str;
        }
    }

    // Key not found.  Return hex string.
    wchar_t buf[11];
    swprintf(buf, _countof(buf), L"0x%p", key);
    return buf;
}

wstr lookupSid(WELL_KNOWN_SID_TYPE type) {
    PSID sid;
    DWORD sidSize;
    LPWSTR str;

    sidSize = SECURITY_MAX_SID_SIZE;
    sid = LocalAlloc(LMEM_FIXED, sidSize);
    if (sid == NULL) {
        printLastError(L"LocalAlloc");
        return L"";
    }

    if (!CreateWellKnownSid(type, NULL, sid, &sidSize)) {
        printLastError(L"CreateWellKnownSid");
        LocalFree(sid);
        return L"";
    }

    if (!ConvertSidToStringSid(sid, &str)) {
        printLastError(L"ConvertSidToStringSid");
        LocalFree(sid);
        return L"";
    }

    wstr ret(str);
    LocalFree(str);
    LocalFree(sid);
    return ret;
}

void printBanner(void) {
    if (mode >= NORMAL) {
        _putws(L"NextLabs Clean-Wipe Utility Version "
               _CRT_WIDE(_CRT_STRINGIZE(VERSION_MAJOR)) L"."
               _CRT_WIDE(_CRT_STRINGIZE(VERSION_MINOR)) L"."
               _CRT_WIDE(_CRT_STRINGIZE(BUILD_NUMBER)) L" for "
#ifdef _WIN64
               L"x64\n"
#else
               L"x86\n"
#endif
               _CRT_WIDE(VER_LEGALCOPYRIGHT_STR) L"\n");
    }
}

void printUsage(const wchar_t *argv1) {
    wprintf(L"Usage: %s [options ...] release\n", argv1);
    _putws(L"\nRelease:");
    _putws(L"\t7.5\t\tclean-wipe RMC 7.5");
    _putws(L"\t7.6\t\tclean-wipe RMC 7.6");
    _putws(L"\nOptions:");
    _putws(L"\t/s\t\tsilent mode");
    _putws(L"\t/v\t\tverbose mode");
    _putws(L"\t/i=<full-path>\toverride installation directory");
    _putws(L"\t/?, /help\tprint this help message");
}



//
// VarStore class
//

VarStore::VarStore(void) {
    // Create our own variables from hard-coded values:
    // - ProductCode, PackageCode, UpgradeCode
    // - SquishedProductCode, SquishedPackageCode, SquishedUpgradeCode
    // - LocalSystemSid
    m_varMap[L"ProductCode_7_5"] = ProductCode_7_5;
    m_varMap[L"PackageCode_7_5"] = PackageCode_7_5;
    m_varMap[L"SquishedProductCode_7_5"] = squishGUID(ProductCode_7_5);
    m_varMap[L"SquishedPackageCode_7_5"] = squishGUID(PackageCode_7_5);
    m_varMap[L"ProductCode_7_6"] = ProductCode_7_6;
    m_varMap[L"PackageCode_7_6"] = PackageCode_7_6;
    m_varMap[L"SquishedProductCode_7_6"] = squishGUID(ProductCode_7_6);
    m_varMap[L"SquishedPackageCode_7_6"] = squishGUID(PackageCode_7_6);
    if (wipe7_5) {
        m_varMap[L"ProductCode"] = ProductCode_7_5;
        m_varMap[L"PackageCode"] = PackageCode_7_5;
        m_varMap[L"SquishedProductCode"] = squishGUID(ProductCode_7_5);
        m_varMap[L"SquishedPackageCode"] = squishGUID(PackageCode_7_5);
    } else {
        m_varMap[L"ProductCode"] = ProductCode_7_6;
        m_varMap[L"PackageCode"] = PackageCode_7_6;
        m_varMap[L"SquishedProductCode"] = squishGUID(ProductCode_7_6);
        m_varMap[L"SquishedPackageCode"] = squishGUID(PackageCode_7_6);
    }
    m_varMap[L"UpgradeCode"] = UpgradeCode;
    m_varMap[L"SquishedUpgradeCode"] = squishGUID(UpgradeCode);
    m_varMap[L"LocalSystemSid"] = lookupSid(WinLocalSystemSid);

    // Create our own variables from Registry values:
    // - InstallDir
    // - LocalMsiPath
    // - Reader10InstallDir
    // - Reader11InstallDir
    static const struct {
        const wchar_t *var;
        bool required;
        HKEY key;
        const wchar_t *subKey;
        const wchar_t *val;
    } varDict[] = {
        {
            L"InstallDir",
            true,
            HKEY_LOCAL_MACHINE,
            L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\%LocalSystemSid%\\Products\\%SquishedProductCode%\\InstallProperties",
            L"InstallLocation"
        }, {
            L"LocalMsiPath",
            true,
            HKEY_LOCAL_MACHINE,
            L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\%LocalSystemSid%\\Products\\%SquishedProductCode%\\InstallProperties",
            L"LocalPackage"
        }, {
            L"Reader10InstallDir",
            false,
            HKEY_LOCAL_MACHINE,
#ifdef _WIN64
            L"SOFTWARE\\Wow6432Node\\Adobe\\Acrobat Reader\\10.0\\Installer",
#else
            L"SOFTWARE\\Adobe\\Acrobat Reader\\10.0\\Installer",
#endif
            L"Path"
        }, {
            L"Reader11InstallDir",
            false,
            HKEY_LOCAL_MACHINE,
#ifdef _WIN64
            L"SOFTWARE\\Wow6432Node\\Adobe\\Acrobat Reader\\11.0\\Installer",
#else
            L"SOFTWARE\\Adobe\\Acrobat Reader\\11.0\\Installer",
#endif
            L"Path"
        }
    };

    // Add InstallDir override if the use specified it.
    if (!installDirOverride.empty()) {
        m_varMap[L"InstallDir"] = installDirOverride;
    }

    for (int i = 0; i < _countof(varDict); i++) {
        // Don't look up installation dir from Registry if the user specified
        // an override.
        if (!installDirOverride.empty() &&
            wcscmp(varDict[i].var, L"InstallDir") == 0) {
            continue;
        }

        wstr subKey(varDict[i].subKey);
        HKEY hKey;
        DWORD lastErr;

        Resolve(subKey);
        lastErr = RegOpenKeyEx(varDict[i].key, subKey.c_str(), 0,
                               KEY_QUERY_VALUE, &hKey);

        if (lastErr != ERROR_SUCCESS) {
            if (varDict[i].required) {
                SetLastError(lastErr);
                printLastError(wstr(L"RegOpenKeyEx(") +
                               regKeyStr(varDict[i].key) + L",\"" + subKey +
                               L"\")");
            }
        } else {
            wstr val(varDict[i].val);
            DWORD type;
            wchar_t buf[MAX_PATH];
            DWORD bufSize = sizeof buf;

            Resolve(val);
            lastErr = RegQueryValueEx(hKey, val.c_str(), NULL, &type,
                                      (LPBYTE) buf, &bufSize);
            if (lastErr != ERROR_SUCCESS) {
                if (varDict[i].required) {
                    SetLastError(lastErr);
                    printLastError(wstr(L"RegQueryValueEx(\"") + val + L")\"");
                }
            } else if (type!=REG_EXPAND_SZ && type!=REG_LINK && type!=REG_SZ) {
                if (varDict[i].required) {
                    if (mode != SILENT) {
                        wprintf(L"ERROR VarStore::VarStore: Cannot find string value \"%s\".\n",
                                val.c_str());
                    }
                }
            } else {
                // Remove any trailing backslash, unless the path is in the
                // form of "C:\".
                if (buf[wcslen(buf)-1] == L'\\' && buf[wcslen(buf)-2] != L':') {
                    buf[wcslen(buf)-1] = L'\0';
                }

                m_varMap[varDict[i].var] = buf;
            }

            RegCloseKey(hKey);
        }
    }

    // If %InstallDir% was not established from either an override or the
    // Registry, see if "%ProgramFiles%\NextLabs\Rights Management" look like
    // an RMC installation dir.  If yes, assume that it is the installation
    // dir.
    //
    // The files which the 7.5/7.6 uninstaller are most likely to leave behind
    // are the JRE font files.  Hence we check the existence of one of the
    // font files.  If it exists, we assume that we have found the
    // installation dir.
    if (m_varMap[L"InstallDir"].empty()) {
        wstr fontPath(L"%ProgramFiles%\\NextLabs\\Rights Management\\jre\\lib\\fonts\\LucidaBrightDemiBold.ttf");

        Resolve(fontPath);
        if (GetFileAttributes(fontPath.c_str()) != INVALID_FILE_ATTRIBUTES) {
            m_varMap[L"InstallDir"] =
                L"%ProgramFiles%\\NextLabs\\Rights Management";
        } else {
            // GetFileAttributes returned error.  Either the file does not
            // exist or there was some other error.  In the latter case, we
            // can't assume that the file exists, so we can't assume that we
            // have found the installation dir.
        }
    }
}

wstr VarStore::Lookup(wstr var) {
    if (!m_varMap[var].empty()) {
        return m_varMap[var];
    } else {
        wchar_t buf[32767];

        if (GetEnvironmentVariable(var.c_str(), buf, _countof(buf)) == 0) {
            if (GetLastError() != ERROR_ENVVAR_NOT_FOUND) {
                printLastError(L"GetEnvironmentVariable");
            }
            return L"";
        } else {
            return buf;
        }
    }
}

// Returns false if some variables cannot be found.
bool VarStore::Resolve(wstr &str, bool hideError) {
    wstr origStr(str);

    // Replace one variable at a time.  Variables can be nested.
    while (1) {
        size_t i, j;
        if ((i = str.find(L'%')) == str.npos) {
            if (mode == DEBUG) {
                wprintf(L"VarStore::Resolve: resolved \"%s\" to \"%s\"\n",
                        origStr.c_str(), str.c_str());
            }
            return true;
        }
        if ((j = str.find(L'%', i+1)) == str.npos) {
            if (mode == DEBUG) {
                wprintf(L"VarStore::Resolve: resolved \"%s\" to \"%s\"\n",
                        origStr.c_str(), str.c_str());
            }
            return true;
        }

        wstr val(Lookup(str.substr(i+1, j-i-1)));
        if (val.empty()) {
            if (!hideError && mode != SILENT) {
                wprintf(L"ERROR VarStore::Resolve: Cannot resolve \"%s\".\n",
                        str.c_str());
            }
            return false;
        }

        str.replace(i, j-i+1, val);
    }
}



//
// SvcWiper class
//

SvcWiper::SvcWiper(void) {
    m_schSCM = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, 0);
    if (m_schSCM == NULL) {
        printLastError(L"OpenSCManager");
        return;
    }

    if (mode == DEBUG) {
        wprintf(L"SvcWiper::SvcWiper succeeded.\n");
    }
}

SvcWiper::~SvcWiper() {
    if (m_schSCM != NULL) {
        if (!CloseServiceHandle(m_schSCM)) {
            printLastError(L"CloseServiceHandle");
            return;
        }
    }

    if (mode == DEBUG) {
        wprintf(L"SvcWiper::~SvcWiper succeeded.\n");
    }
}

bool SvcWiper::Delete(const wchar_t *svcName) {
    const wstr argStr(wstr(L"(") + svcName + L")");

    if (m_schSCM == NULL) {
        return false;
    }

    // Open service.
    SC_HANDLE schService;
    schService = OpenService(m_schSCM, svcName,
                             SERVICE_QUERY_STATUS | SERVICE_STOP | DELETE);
    if (schService == NULL) {
        printLastError(wstr(L"OpenService") + argStr);
        return false;
    }

    if (mode == DEBUG) {
        wprintf(L"OpenService(\"%s\") succeeded.\n", svcName);
    }

    // See if it is currently stopped.
    SERVICE_STATUS status;

    if (!QueryServiceStatus(schService, &status)) { 
        printLastError(wstr(L"QueryServiceStatus") + argStr);
        CloseServiceHandle(schService);
        return false;
    }

    if (mode >= VERBOSE) {
        wprintf(L"%s service current state = %lu\n", svcName,
                status.dwCurrentState);
    }

    if (status.dwCurrentState != SERVICE_STOPPED) {
        // Stop the service.
        if (!ControlService(schService, SERVICE_CONTROL_STOP, &status)) {
            printLastError(wstr(L"ControlService") + argStr);
            CloseServiceHandle(schService);
            return false;
        }

        if (mode >= VERBOSE) {
            wprintf(L"%s service has been stopped.\n", svcName);
        }
    }

    // Delete the service.
    if (!DeleteService(schService)) {
        printLastError(wstr(L"DeleteService") + argStr);
        CloseServiceHandle(schService);
        return false;
    }

    CloseServiceHandle(schService);

    if (mode >= VERBOSE) {
        wprintf(L"%s service has been deleted.\n", svcName);
    }

    return true;
}



//
// AsmWiper class
//

bool AsmWiper::Delete(const wchar_t *asmFullPath, bool isX64) {
    wstr cmdLine;
    STARTUPINFO startupInfo = {0};
    PROCESS_INFORMATION procInfo;

    cmdLine = L"%SystemRoot%\\Microsoft.NET\\Framework";
    if (isX64) {
        cmdLine += L"64";
    }
    cmdLine += L"\\v2.0.50727\\RegAsm.exe \"";
    cmdLine += asmFullPath;
    cmdLine += L"\" /unregister";
    if (mode == SILENT) {
        cmdLine += L" /silent";
    } else if (mode >= VERBOSE) {
        cmdLine += L" /verbose";
    }

    if (!pVarStore->Resolve(cmdLine)) {
        return false;
    }

    wchar_t cmdLineBuf[MAX_PATH];
    wcscpy_s(cmdLineBuf, cmdLine.c_str());
    if (!CreateProcess(NULL, cmdLineBuf, NULL, NULL, FALSE, 0, NULL, NULL,
                       &startupInfo, &procInfo)) {
        printLastError(L"CreateProcess");
        return false;
    }

    bool ret = true;

    WaitForSingleObject(procInfo.hProcess, INFINITE);

    DWORD exitCode;
    if (GetExitCodeProcess(procInfo.hProcess, &exitCode)) {
        if (exitCode != 0) {
            ret = false;
        }
    } else {
        ret = false;
    }

    CloseHandle(procInfo.hThread);
    CloseHandle(procInfo.hProcess);
    return ret;
}



//
// RegWiper class
//

bool RegWiper::DeleteValue(HKEY key, const wchar_t *subKey,
                           const wchar_t *value) {
    const wstr argStr(wstr(L"(") + regKeyStr(key) + L"," + subKey + L"," +
                      value + L")");

    wstr subKeyStr(subKey), valueStr(value);
    if (!pVarStore->Resolve(subKeyStr) || !pVarStore->Resolve(valueStr)) {
        return false;
    }

    DWORD lastErr;
    lastErr = RegDeleteKeyValue(key, subKeyStr.c_str(), valueStr.c_str());
    if (lastErr == ERROR_SUCCESS) {
        return true;
    } else {
        SetLastError(lastErr);
        printLastError(wstr(L"RegDeleteValue") + argStr);
        return false;
    }
}

bool RegWiper::DeleteTree(HKEY key, const wchar_t *subKey) {
    const wstr argStr(wstr(L"(") + regKeyStr(key) + L"," + subKey + L")");

    wstr subKeyStr(subKey);
    if (!pVarStore->Resolve(subKeyStr)) {
        return false;
    }

    DWORD lastErr;
    lastErr = RegDeleteTree(key, subKeyStr.c_str());
    if (lastErr == ERROR_SUCCESS) {
        return true;
    } else {
        SetLastError(lastErr);
        printLastError(wstr(L"RegDeleteTree") + argStr);
        return false;
    }
}

bool RegWiper::DeleteKeyIfEmpty(HKEY key, const wchar_t *subKey) {
    const wstr argStr(wstr(L"(") + regKeyStr(key) + L"," + subKey + L")");

    HKEY hKey;
    DWORD lastErr;

    lastErr = RegOpenKeyEx(key, subKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lastErr != ERROR_SUCCESS) {
        SetLastError(lastErr);
        printLastError(wstr(L"RegOpenKeyEx") + argStr);
        return false;
    }

    DWORD nSubKeys, nValues;
    lastErr = RegQueryInfoKey(hKey, NULL, NULL, NULL, &nSubKeys, NULL, NULL,
                              &nValues, NULL, NULL, NULL, NULL);
    if (lastErr != ERROR_SUCCESS) {
        SetLastError(lastErr);
        printLastError(wstr(L"RegQueryInfoKey") + argStr);
        RegCloseKey(hKey);
        return false;
    }

    if (nSubKeys == 0 && nValues == 0) {
        lastErr = RegDeleteKey(key, subKey);
        if (lastErr != ERROR_SUCCESS) {
            SetLastError(lastErr);
            printLastError(wstr(L"RegDeleteKey") + argStr);
            RegCloseKey(hKey);
            return false;
        }
    }

    RegCloseKey(hKey);
    return true;
}



//
// FileAssocWiper class
//

bool FileAssocWiper::DeleteExt(const wchar_t *ext) {
    return pRegWiper->DeleteTree(HKEY_CLASSES_ROOT, ext);
}

bool FileAssocWiper::DeleteType(const wchar_t *type) {
    return pRegWiper->DeleteTree(HKEY_CLASSES_ROOT, type);
}



//
// FontWiper class
//

bool FontWiper::Delete(const wchar_t *fontName) {
    return pRegWiper->DeleteValue(HKEY_LOCAL_MACHINE,
                                  L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Fonts",
                                  fontName);
}



//
// FileWiper class
//

bool FileWiper::Delete(const wchar_t *fileFullPath, bool ignoreMissing) {
    wstr fileStr(fileFullPath);
    if (!pVarStore->Resolve(fileStr, ignoreMissing)) {
        return false;
    }

    const wstr argStr(wstr(L"(") + fileStr + L")");

    DWORD attrs = GetFileAttributes(fileStr.c_str());

    if (attrs == INVALID_FILE_ATTRIBUTES) {
        if (GetLastError() == ERROR_FILE_NOT_FOUND) {
            return true;
        }

        printLastError(wstr(L"GetFileAttributes") + argStr);
        return false;
    }

    if (attrs & FILE_ATTRIBUTE_READONLY) {
        if (!SetFileAttributes(fileStr.c_str(),
                               attrs & ~FILE_ATTRIBUTE_READONLY)) {
            printLastError(wstr(L"SetFileAttributes") + argStr);
            return false;
        }
    }
        
    if (DeleteFile(fileStr.c_str())) {
        return true;
    }

    if (!MoveFileEx(fileStr.c_str(), NULL, MOVEFILE_DELAY_UNTIL_REBOOT)) {
        printLastError(wstr(L"MoveFileEx") + argStr);
        return false;
    }

    if (mode >= VERBOSE) {
        wprintf(L"%s will be deleted after rebooting.\n", fileStr.c_str());
    }

    return true;
}



//
// DirWiper class
//

bool DirWiper::Delete(const wchar_t *dirFullPath, bool ignoreMissing) {
    wchar_t oldDirFullPath[MAX_PATH];
    if (GetCurrentDirectory(_countof(oldDirFullPath), oldDirFullPath) == 0) {
        printLastError(L"GetCurrentDir");
        return false;
    }

    wstr dirStr(dirFullPath);
    if (!pVarStore->Resolve(dirStr, ignoreMissing)) {
        return false;
    }

    const wstr argStr(wstr(L"(") + dirStr + L")");

    if (!SetCurrentDirectory(dirStr.c_str())) {
        printLastError(wstr(L"SetCurrentDirectory") + argStr);
        return false;
    }

    WIN32_FIND_DATA data;
    HANDLE h;
    bool ret = true;

    h = FindFirstFile(L"*", &data);
    if (h == INVALID_HANDLE_VALUE && GetLastError() != ERROR_FILE_NOT_FOUND) {
        printLastError(wstr(L"FileFirstFile") + argStr);
        // Don't stop.  Try to delete the directory anyway.
    }

    if (h != INVALID_HANDLE_VALUE) {
        do {
            if (data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                if (wcscmp(data.cFileName, L".") == 0 ||
                    wcscmp(data.cFileName, L"..") == 0) {
                    continue;
                }

                // Recurse.
                if (!Delete((dirStr + L'\\' + data.cFileName).c_str())) {
                    ret = false;
                }
            } else {
                if (!pFileWiper->Delete((dirStr+L'\\' + data.cFileName)
                                        .c_str())) {
                    ret = false;
                }
            }
        } while (FindNextFile(h, &data));
    }

    FindClose(h);

    SetCurrentDirectory(L".."); // ignore error
    if (!RemoveDirectory(dirStr.c_str())) {
        if (MoveFileEx(dirStr.c_str(), NULL, MOVEFILE_DELAY_UNTIL_REBOOT)) {
            if (mode >= VERBOSE) {
                wprintf(L"%s will be deleted after rebooting if empty.\n",
                        dirStr.c_str());
            }
        } else {
            printLastError(wstr(L"MoveFileEx") + argStr);
            ret = false;
        }
    }

    SetCurrentDirectory(oldDirFullPath);
    return ret;
}

bool DirWiper::DeleteNoRecurse(const wchar_t *dirFullPath) {
    wstr dirStr(dirFullPath);
    if (!pVarStore->Resolve(dirStr)) {
        return false;
    }

    const wstr argStr(wstr(L"(") + dirStr + L")");

    if (RemoveDirectory(dirStr.c_str())) {
        return true;
    }

    if (!MoveFileEx(dirStr.c_str(), NULL, MOVEFILE_DELAY_UNTIL_REBOOT)) {
        printLastError(wstr(L"MoveFileEx(") + dirStr + L")");
        return false;
    }

    if (mode >= VERBOSE) {
        wprintf(L"%s will be deleted after rebooting if empty.\n",
                dirStr.c_str());
    }

    return true;
}



//
// wmain
//

int wmain(int argc, const wchar_t * const argv[]) {
    //
    // Parse command-line arguments.
    //
    for (int i = 1; i < argc; i++) {
        if (argv[i][0] == L'/') {
            // Parse option.
            if (wcscmp(argv[i], L"/s") == 0) {
                mode = SILENT;
            } else if (wcscmp(argv[i], L"/v") == 0) {
                mode = VERBOSE;
            } else if (wcscmp(argv[i], L"/d") == 0) {
                // Debug mode option is not advertised in help message.
                mode = DEBUG;
            } else if (wcsncmp(argv[i], L"/i=", 3) == 0 &&
                       wcslen(argv[i]) > 3) {
                installDirOverride = &argv[i][3];
            } else if (wcscmp(argv[i], L"/?") == 0 ||
                       wcscmp(argv[i], L"/help") == 0) {
                printBanner();
                printUsage(argv[0]);
                return EXIT_SUCCESS;
            } else {
                printBanner();
                wprintf(L"ERROR: Unknown option: %s\n", argv[i]);
                return EXIT_INVALID_PARAMETER;
            }
        } else {
            // Parse release.
            if (wcscmp(argv[i], L"7.5") == 0) {
                wipe7_5 = true;
            } else if (wcscmp(argv[i], L"7.6") == 0) {
                wipe7_6 = true;
            } else {
                printBanner();
                wprintf(L"ERROR: Unknown release: %s\n", argv[i]);
                return EXIT_INVALID_PARAMETER;
            }
        }
    }

    printBanner();

    if (wipe7_5 == wipe7_6) {
        _putws(L"ERROR: Exactly one of \"7.5\" or \"7.6\" must be specified.");
        return EXIT_INVALID_PARAMETER;
    }

#ifndef _WIN64
    // 32-bit utility does not support 64-bit machines.
    SYSTEM_INFO info;
    GetNativeSystemInfo(&info);
    if (info.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL) {
        if (mode != SILENT) {
            _putws(L"ERROR: This version of the utility does not support x64 systems.  Please use the x64 version instead.");
        }
        return EXIT_PLATFORM_NOT_SUPPORTED;
    }
#endif

    bool ret = true;
    int i;

    pVarStore = new VarStore;
    pSvcWiper = new SvcWiper;
    pAsmWiper = new AsmWiper;
    pRegWiper = new RegWiper;
    pFileAssocWiper = new FileAssocWiper;
    pFontWiper = new FontWiper;
    pFileWiper = new FileWiper;
    pDirWiper = new DirWiper;

    //
    // Remove nxrmcservice service.
    //
    if (!pSvcWiper->Delete(L"nxrmcservice")) {
        ret = false;
    }
    
    //
    // Unregister assemblies
    //
    const struct {const wchar_t *asmPath; bool isX64;} asms[] = {
#ifdef _WIN64
        {L"%InstallDir%\\bin\\x86\\NLContextMenu.dll",  false},
        {L"%InstallDir%\\bin\\x86\\NLCommonUI.dll",     false},
        {L"%InstallDir%\\bin\\NLContextMenu.dll",       true},
        {L"%InstallDir%\\bin\\NLCommonUI.dll",          true},
#else
        {L"%InstallDir%\\bin\\NLContextMenu.dll",       false},
        {L"%InstallDir%\\bin\\NLCommonUI.dll",          false},
#endif
    };

    for (i = 0; i < _countof(asms); i++) {
        if (!pAsmWiper->Delete(asms[i].asmPath, asms[i].isX64)) {
            ret = false;
        }
    }

    //
    // Remove nxrmc driver.
    //
    if (!pSvcWiper->Delete(L"nxrmc")) {
        ret = false;
    }
    if (!pFileWiper->Delete(L"%SystemRoot%\\System32\\drivers\\nxrmc.sys")) {
        ret = false;
    }

    //
    // Delete Registry keys.
    //
    const struct {bool delParentIfEmpty; HKEY key; const wchar_t *subKey;}
    regTrees[] = {
        {true,  HKEY_CURRENT_USER,  L"Software\\NextLabs\\Configure"},
        {true,  HKEY_LOCAL_MACHINE, L"SOFTWARE\\NextLabs\\Configure"},
        {true,  HKEY_LOCAL_MACHINE, L"SOFTWARE\\NextLabs\\Rights Management"},
        {false, HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\services\\eventlog\\NextLabs"},
        {false, HKEY_LOCAL_MACHINE, L"SOFTWARE\\Classes\\Installer\\Features\\%SquishedProductCode%"},
        {false, HKEY_LOCAL_MACHINE, L"SOFTWARE\\Classes\\Installer\\Products\\%SquishedProductCode%"},
        {false, HKEY_LOCAL_MACHINE, L"SOFTWARE\\Classes\\Installer\\UpgradeCodes\\%SquishedUpgradeCode%"},
        {false, HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Installer\\UpgradeCodes\\%SquishedUpgradeCode%"},
        {false, HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\%LocalSystemSid%\\Products\\%SquishedProductCode%"},
        {false, HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\%ProductCode%"}
    };

    for (i = 0; i < _countof(regTrees); i++) {
        if (!pRegWiper->DeleteTree(regTrees[i].key, regTrees[i].subKey)) {
            ret = false;
        } else {
            if (regTrees[i].delParentIfEmpty) {
                wstr parentKey(regTrees[i].subKey);
                parentKey.erase(parentKey.rfind(L'\\'));

                if (!pRegWiper->DeleteKeyIfEmpty(regTrees[i].key,
                                                 parentKey.c_str())) {
                    ret = false;
                }
            }
        }
    }

    //
    // Delete installer-related files and directories.
    //
    const struct {bool required; bool isDir; const wchar_t *path;}
    pathsToDel[] = {
        {true,  false, L"%SystemRoot%\\Installer\\SourceHash%ProductCode%"},
        {true,  true,  L"%SystemRoot%\\Installer\\%ProductCode%"},
        {true,  false, L"%LocalMsiPath%"},
        {false, false, L"%Reader10InstallDir%\\Reader\\plug_ins\\AdobeREP.api"},
        {false, false, L"%Reader11InstallDir%\\Reader\\plug_ins\\AdobeREP.api"}
    };

    for (i = 0; i < _countof(pathsToDel); i++) {
        if (!(pathsToDel[i].isDir ?
              pDirWiper->Delete(pathsToDel[i].path, !pathsToDel[i].required) :
              pFileWiper->Delete(pathsToDel[i].path,!pathsToDel[i].required))) {
            ret = false;
        }
    }

    //
    // Remove .nxl file extension and nxlfile file type.
    //
    if (!pFileAssocWiper->DeleteExt(L".nxl")) {
        ret = false;
    }
    if (!pFileAssocWiper->DeleteType(L"nxlfile")) {
        ret = false;
    }

    //
    // Remove JRE fonts from system
    //
    const wchar_t * const jreFonts[] = {
        L"Lucida Bright Demibold (TrueType)",
        L"Lucida Bright Demibold Italic (TrueType)",
        L"Lucida Bright Italic (TrueType)",
        L"Lucida Bright Regular (TrueType)",
        L"Lucida Sans Demibold (TrueType)",
        L"Lucida Sans Regular (TrueType)",
        L"Lucida Sans Typewriter Bold (TrueType)",
        L"Lucida Sans Typewriter Regular (TrueType)"
    };

    for (i = 0; i < _countof(jreFonts); i++) {
        if (!pFontWiper->Delete(jreFonts[i])) {
            ret = false;
        }
    }

    //
    // Delete the installation directory.
    //
    // Delete the parent dir of the installation directory if it is not a root
    // dir, its name is "NextLabs" (case insensitive), and it is empty.
    //
    wstr parentDirPath;
    parentDirPath = L"%InstallDir%";
    if (pVarStore->Resolve(parentDirPath)) {
        parentDirPath.erase(parentDirPath.rfind(L'\\'));

        size_t index;
        wstr parentDirName;
        index = parentDirPath.rfind(L'\\');
        if (index != parentDirPath.npos) {
            // Parent dir not a root dir.
            parentDirName = parentDirPath.substr(index + 1);
        }

        if (!pDirWiper->Delete(L"%InstallDir%")) {
            ret = false;
        }

        if (_wcsicmp(parentDirName.c_str(), L"NextLabs") == 0) {
            if (!pDirWiper->DeleteNoRecurse(parentDirPath.c_str())) {
                ret = false;
            }
        }
    }

    //
    // Delete RMC Start menu folder and item.  Then delete the NextLabs, Inc
    // folder if it's empty.
    //
    // For some reason, the RMC folder name is "Rights Management" in 32-bit
    // but "Nextlabs Rights Management" in 64-bit.
    //
    const wstr nxStartMenuFolderPath(L"%ProgramData%\\Microsoft\\Windows\\Start Menu\\Programs\\NextLabs, Inc");
#ifdef _WIN64
    const wstr rmcStartMenuFolderPath = nxStartMenuFolderPath +
        L"\\Nextlabs Rights Management";
#else
    const wstr rmcStartMenuFolderPath = nxStartMenuFolderPath +
        L"\\Rights Management";
#endif

    if (!pDirWiper->Delete(rmcStartMenuFolderPath.c_str())) {
        ret = false;
    }

    if (!pDirWiper->DeleteNoRecurse(nxStartMenuFolderPath.c_str())) {
        ret = false;
    }

    delete pDirWiper;
    delete pFileWiper;
    delete pFontWiper;
    delete pFileAssocWiper;
    delete pRegWiper;
    delete pAsmWiper;
    delete pSvcWiper;
    delete pVarStore;

    return ret ? EXIT_SUCCESS : EXIT_FAILURE;
}
