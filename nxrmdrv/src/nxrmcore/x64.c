#include <windows.h>
#include "x64.h"
#include "disasm.h"

UCHAR x64_table[] = {
  0xa5,0xaa,0xa5,0xb8,0xa5,0xaa,0xa5,0xaa,0xa5,0xb8,0xa5,0xb8,0xa5,0xb8,0xa5,
  0xb8,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xac,0xc0,0xcc,0xc0,0xa1,0xa1,
  0xa1,0xa1,0xb1,0xa5,0xa5,0xa6,0xc0,0xc0,0xd7,0xda,0xe0,0xc0,0xe4,0xc0,0xea,
  0xea,0xe0,0xe0,0x98,0xc8,0xee,0xf1,0xa5,0xd3,0xa5,0xa5,0xa1,0xea,0x9e,0xc0,
  0xc0,0xc2,0xc0,0xe6,0x03,0x7f,0x11,0x7f,0x01,0x7f,0x01,0x3f,0x01,0x01,0xab,
  0x8b,0x90,0x64,0x5b,0x5b,0x5b,0x5b,0x5b,0x92,0x5b,0x5b,0x76,0x90,0x92,0x92,
  0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x6a,0x73,0x90,
  0x5b,0x52,0x52,0x52,0x52,0x5b,0x5b,0x5b,0x5b,0x77,0x7c,0x77,0x85,0x5b,0x5b,
  0x70,0x5b,0x7a,0xaf,0x76,0x76,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,
  0x5b,0x5b,0x86,0x01,0x03,0x01,0x04,0x03,0xd5,0x03,0xd5,0x03,0xcc,0x01,0xbc,
  0x03,0xf0,0x03,0x03,0x04,0x00,0x50,0x50,0x50,0x50,0xff,0x20,0x20,0x20,0x20,
  0x01,0x01,0x01,0x01,0xc4,0x02,0x10,0xff,0xff,0xff,0x01,0x00,0x03,0x11,0xff,
  0x03,0xc4,0xc6,0xc8,0x02,0x10,0x00,0xff,0xcc,0x01,0x01,0x01,0x00,0x00,0x00,
  0x00,0x01,0x01,0x03,0x01,0xff,0xff,0xc0,0xc2,0x10,0x11,0x02,0x03,0x01,0x01,
  0x01,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0x00,0x00,0xff,0xff,0xff,0xff,0x10,
  0x10,0x10,0x10,0x02,0x10,0x00,0x00,0xc6,0xc8,0x02,0x02,0x02,0x02,0x06,0x00,
  0x04,0x00,0x02,0xff,0x00,0xc0,0xc2,0x01,0x01,0x03,0x03,0x03,0xca,0x40,0x00,
  0x0a,0x00,0x04,0x00,0x00,0x00,0x00,0x7f,0x00,0x33,0x01,0x00,0x00,0x00,0x00,
  0x00,0x00,0xff,0xbf,0xff,0xff,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0xff,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,
  0x00,0x00,0x00,0xbf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0x00,0x00,
  0xff,0x40,0x40,0x40,0x40,0x41,0x49,0x40,0x40,0x40,0x40,0x4c,0x42,0x40,0x40,
  0x40,0x40,0x40,0x40,0x40,0x40,0x4f,0x44,0x53,0x40,0x40,0x40,0x44,0x57,0x43,
  0x5c,0x40,0x60,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x64,0x66,0x6e,0x6b,0x40,0x40,0x6a,0x46,0x40,0x40,0x44,0x46,0x40,
  0x40,0x5b,0x44,0x40,0x40,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,0x01,0x06,
  0x06,0x02,0x06,0x06,0x00,0x06,0x00,0x0a,0x0a,0x00,0x00,0x00,0x02,0x07,0x07,
  0x06,0x02,0x0d,0x06,0x06,0x06,0x0e,0x05,0x05,0x02,0x02,0x00,0x00,0x04,0x04,
  0x04,0x04,0x05,0x06,0x06,0x06,0x00,0x00,0x00,0x0e,0x00,0x00,0x08,0x00,0x10,
  0x00,0x18,0x00,0x20,0x00,0x28,0x00,0x30,0x00,0x80,0x01,0x82,0x01,0x86,0x00,
  0xf6,0xcf,0xfe,0x3f,0xab,0x00,0xb0,0x00,0xb1,0x00,0xb3,0x00,0xba,0xf8,0xbb,
  0x00,0xc0,0x00,0xc1,0x00,0xc7,0xbf,0x62,0xff,0x00,0x8d,0xff,0x00,0xc4,0xff,
  0x00,0xc5,0xff,0x00,0xff,0xff,0xeb,0x01,0xff,0x0e,0x12,0x08,0x00,0x13,0x09,
  0x00,0x16,0x08,0x00,0x17,0x09,0x00,0x2b,0x09,0x00,0xae,0xff,0x07,0xb2,0xff,
  0x00,0xb4,0xff,0x00,0xb5,0xff,0x00,0xc3,0x01,0x00,0xc7,0xff,0xbf,0xe7,0x08,
  0x00,0xf0,0x02,0x00
};

unsigned int __stdcall x64_disasm(const void *code, x64s *instruinfo)
{
	UCHAR x = 0;
	UCHAR c = 0;
	UCHAR *p = (UCHAR *)code;
	UCHAR cflags = 0;
	UCHAR opcode = 0;
	UCHAR pref = 0;
	UCHAR *x64t = x64_table;
	UCHAR m_mod = 0;
	UCHAR m_reg = 0;
	UCHAR m_rm = 0;
	UCHAR disp_size = 0;
	UCHAR op64 = 0;

	memset(instruinfo, 0, sizeof(x64s));

	for (x = 16; x; x--)
	{
		switch (c = *p++) 
		{
			case 0xf3:
				instruinfo->p_rep = c;
				pref |= PRE_F3;
				break;
			case 0xf2:
				instruinfo->p_rep = c;
				pref |= PRE_F2;
				break;
			case 0xf0:
				instruinfo->p_lock = c;
				pref |= PRE_LOCK;
				break;
			case 0x26: case 0x2e: case 0x36:
			case 0x3e: case 0x64: case 0x65:
				instruinfo->p_seg = c;
				pref |= PRE_SEG;
				break;
			case 0x66:
				instruinfo->p_66 = c;
				pref |= PRE_66;
				break;
			case 0x67:
				instruinfo->p_67 = c;
				pref |= PRE_67;
				break;
			default:
				goto pref_done;
		}
	}

  pref_done:

	instruinfo->flags = (ULONG)pref << 23;

	if (!pref)
		pref |= PRE_NONE;

	if ((c & 0xf0) == 0x40) 
	{
		instruinfo->flags |= F_PREFIX_REX;
		if ((instruinfo->rex_w = (c & 0xf) >> 3) && (*p & 0xf8) == 0xb8)
			op64++;
		instruinfo->rex_r = (c & 7) >> 2;
		instruinfo->rex_x = (c & 3) >> 1;
		instruinfo->rex_b = c & 1;
		if (((c = *p++) & 0xf0) == 0x40)
		{
			opcode = c;
			goto error_opcode;
		}
	}

	if ((instruinfo->opcode = c) == 0x0f) 
	{
		instruinfo->opcode2 = c = *p++;
		x64t += DELTA_OPCODES;
	} 
	else if (c >= 0xa0 && c <= 0xa3) 
	{
		op64++;

		if (pref & PRE_67)
			pref |= PRE_66;
		else
			pref &= ~PRE_66;
	}

	opcode = c;
	cflags = x64t[x64t[opcode / 4] + (opcode % 4)];

	if (cflags == C_ERROR) 
	{
	  error_opcode:
		instruinfo->flags |= F_ERROR | F_ERROR_OPCODE;
		cflags = 0;
		if ((opcode & -3) == 0x24)
			cflags++;
	}

	x = 0;
	if (cflags & C_GROUP) 
	{
		USHORT t = 0;
		t = *(USHORT *)(x64t + (cflags & 0x7f));
		cflags = (UCHAR)t;
		x = (UCHAR)(t >> 8);
	}

	if (instruinfo->opcode2) 
	{
		x64t = x64_table + DELTA_PREFIXES;
		if (x64t[x64t[opcode / 4] + (opcode % 4)] & pref)
			instruinfo->flags |= F_ERROR | F_ERROR_OPCODE;
	}

	if (cflags & C_MODRM) 
	{
		instruinfo->flags |= F_MODRM;
		instruinfo->modrm = c = *p++;
		instruinfo->modrm_mod = m_mod = c >> 6;
		instruinfo->modrm_rm = m_rm = c & 7;
		instruinfo->modrm_reg = m_reg = (c & 0x3f) >> 3;

		if (x && ((x << m_reg) & 0x80))
			instruinfo->flags |= F_ERROR | F_ERROR_OPCODE;

		if (!instruinfo->opcode2 && opcode >= 0xd9 && opcode <= 0xdf) 
		{
			UCHAR t = opcode - 0xd9;
			if (m_mod == 3) 
			{
				x64t = x64_table + DELTA_FPU_MODRM + t*8;
				t = x64t[m_reg] << m_rm;
			} 
			else 
			{
				x64t = x64_table + DELTA_FPU_REG;
				t = x64t[t] << m_reg;
			}

			if (t & 0x80)
				instruinfo->flags |= F_ERROR | F_ERROR_OPCODE;
		}

		if (pref & PRE_LOCK)
		{
			if (m_mod == 3)
			{
				instruinfo->flags |= F_ERROR | F_ERROR_LOCK;
			} 
			else
			{
				UCHAR *table_end, op = opcode;

				if (instruinfo->opcode2)
				{
					x64t = x64_table + DELTA_OP2_LOCK_OK;
					table_end = x64t + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;
				}
				else 
				{
					x64t = x64_table + DELTA_OP_LOCK_OK;
					table_end = x64t + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;
					op &= -2;
				}

				for (; x64t != table_end; x64t++)
				{
					if (*x64t++ == op)
					{
						if (!((*x64t << m_reg) & 0x80))
							goto no_lock_error;
						else
							break;
					}
				}

				instruinfo->flags |= F_ERROR | F_ERROR_LOCK;
			  no_lock_error:
				;
			}
		}

		if (instruinfo->opcode2)
		{
			switch (opcode)
			{
				case 0x20: case 0x22:
					m_mod = 3;
					if (m_reg > 4 || m_reg == 1)
						goto error_operand;
					else
						goto no_error_operand;
				case 0x21: case 0x23:
					m_mod = 3;
					if (m_reg == 4 || m_reg == 5)
						goto error_operand;
					else
						goto no_error_operand;
			}

		}
		else 
		{
			switch (opcode) 
			{
				case 0x8c:
					if (m_reg > 5)
						goto error_operand;
					else
						goto no_error_operand;
				case 0x8e:
					if (m_reg == 1 || m_reg > 5)
						goto error_operand;
					else
						goto no_error_operand;
			}
		}

		if (m_mod == 3)
		{
			UCHAR *table_end = NULL;

			if (instruinfo->opcode2) 
			{
				x64t = x64_table + DELTA_OP2_ONLY_MEM;
				table_end = x64t + sizeof(x64_table) - DELTA_OP2_ONLY_MEM;
			}
			else 
			{
				x64t = x64_table + DELTA_OP_ONLY_MEM;
				table_end = x64t + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;
			}

			for (; x64t != table_end; x64t += 2)
			{
				if (*x64t++ == opcode) 
				{
					if (*x64t++ & pref && !((*x64t << m_reg) & 0x80))
						goto error_operand;
					else
						break;
				}
			}

			goto no_error_operand;

		} 
		else if (instruinfo->opcode2)
		{
			switch (opcode)
			{
				case 0x50: case 0xd7: case 0xf7:
					if (pref & (PRE_NONE | PRE_66))
						goto error_operand;
					break;
				case 0xd6:
					if (pref & (PRE_F2 | PRE_F3))
						goto error_operand;
					break;
				case 0xc5:
					goto error_operand;
			}
		
			goto no_error_operand;
		} 
		else
			goto no_error_operand;

	  error_operand:
		instruinfo->flags |= F_ERROR | F_ERROR_OPERAND;
	  no_error_operand:

		c = *p++;
		if (m_reg <= 1) 
		{
			if (opcode == 0xf6)
				cflags |= C_IMM8;
			else if (opcode == 0xf7)
				cflags |= C_IMM_P66;
		}

		switch (m_mod) 
		{
			case 0:
				if (pref & PRE_67) 
				{
					if (m_rm == 6)
						disp_size = 2;
				} 
				else
					if (m_rm == 5)
						disp_size = 4;
				break;
			case 1:
				disp_size = 1;
				break;
			case 2:
				disp_size = 2;
				if (!(pref & PRE_67))
					disp_size <<= 1;
		}

		if (m_mod != 3 && m_rm == 4) 
		{
			instruinfo->flags |= F_SIB;
			p++;
			instruinfo->sib = c;
			instruinfo->sib_scale = c >> 6;
			instruinfo->sib_index = (c & 0x3f) >> 3;
			if ((instruinfo->sib_base = c & 7) == 5 && !(m_mod & 1))
				disp_size = 4;
		}

		p--;
		switch (disp_size) 
		{
			case 1:
				instruinfo->flags |= F_DISP8;
				instruinfo->disp.disp8 = *p;
				break;
			case 2:
				instruinfo->flags |= F_DISP16;
				instruinfo->disp.disp16 = *(USHORT *)p;
				break;
			case 4:
				instruinfo->flags |= F_DISP32;
				instruinfo->disp.disp32 = *(ULONG *)p;
		}
		p += disp_size;
	} 
	else if (pref & PRE_LOCK)
		instruinfo->flags |= F_ERROR | F_ERROR_LOCK;

	if (cflags & C_IMM_P66)
	{
		if (cflags & C_REL32) 
		{
			if (pref & PRE_66) 
			{
				instruinfo->flags |= F_IMM16 | F_RELATIVE;
				instruinfo->imm.imm16 = *(USHORT *)p;
				p += 2;
				goto disasm_done;
			}
			goto rel32_ok;
		}
		if (op64) 
		{
			instruinfo->flags |= F_IMM64;
			instruinfo->imm.imm64 = *(unsigned long long *)p;
			p += 8;
		} 
		else if (!(pref & PRE_66)) 
		{
			instruinfo->flags |= F_IMM32;
			instruinfo->imm.imm32 = *(ULONG *)p;
			p += 4;
		} 
		else
			goto imm16_ok;
	}


	if (cflags & C_IMM16) 
	{
	  imm16_ok:
		instruinfo->flags |= F_IMM16;
		instruinfo->imm.imm16 = *(USHORT *)p;
		p += 2;
	}

	if (cflags & C_IMM8) 
	{
		instruinfo->flags |= F_IMM8;
		instruinfo->imm.imm8 = *p++;
	}

	if (cflags & C_REL32) 
	{
	  rel32_ok:
		instruinfo->flags |= F_IMM32 | F_RELATIVE;
		instruinfo->imm.imm32 = *(ULONG *)p;
		p += 4;

	} 
	else if (cflags & C_REL8) 
	{
		instruinfo->flags |= F_IMM8 | F_RELATIVE;
		instruinfo->imm.imm8 = *p++;
	}

  disasm_done:

	if ((instruinfo->len = (UCHAR)(p-(UCHAR *)code)) > 15) 
	{
		instruinfo->flags |= F_ERROR | F_ERROR_LENGTH;
		instruinfo->len = 15;
	}

	return (unsigned int)instruinfo->len;
}

#ifdef _AMD64_

ULONG x64GetCurrentInstructionLength(PBYTE ins)
{
	ULONG	uRet = 0;
	
	x64s	Info = {0};

	memset(&Info,0,sizeof(Info));

	x64_disasm(ins, &Info);

	if(!(Info.flags & F_ERROR))
	{
		uRet = Info.len;
	}

	return uRet;
}

#endif